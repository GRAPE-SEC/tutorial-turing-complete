# 2’s Complement(2의 보수법)

# 보수(Complement)

어떤 숫자 A 가 있을때,

A + B = N

를 만족하는 B 를 A의 “N의보수”라고 한다.

걍 이런거임

```
숫자 3 이 있다
3 의 10의 보수는? : 7
7의 보수는? : 4
9의 보수는? : 6
```

# 컴퓨터에서 음수를 표현하는 방법

여태껏 다룬 값은 다 양수였다. 0 보다 크다는 말이다.

![image.png](2%E2%80%99s%20Complement(2%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%A9%E1%84%89%E1%85%AE%E1%84%87%E1%85%A5%E1%86%B8)%201bc80ae0869c8153a420c4e352ddd215/image.png)

```
사과가 3개이면, 전기신호 켜짐(1) 이 3개
사과가 5개이면, 전기신호 켜짐(1) 이 5개
사과가 1F개이면, 전기신호 켜짐(1) 이 1F개
```

근데 이제 마이너스 숫자 그니까 0보다 작은 음수(Negative Number)를 다루려면 곤란하다…. 그런 숫자는 없다.

그래서 초기 컴퓨터는 **부호 표기 방식(Sign-Magnitude Representation)**을 썼습니다.

- 맨 앞에 있는 bit 를 **부호용**으로 따로 빼둡니다.
- 4자리 숫자면, 원래 3자리만 숫자용으로 쓰고 맨 앞은 음수인지 양수인지 씁니다. 맨 앞이 1 이면 음수고 0 이면 양수
    - 예를 들어, 1011 은 -4 고 0011 은 +4
- 앞에 있는 부호를 표시하는 bit 을 **부호비트**라고 부릅니다.

그리고 뺄셈은 **전감산기(Full Subtractor)**를 써서 합니다.

### 전감산기의 진리표

| A | B | B_in | Difference (D) | Borrow (B_out) |
| --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 1 |
| 0 | 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 0 |
| 1 | 1 | 0 | 0 | 0 |
| 1 | 1 | 1 | 1 | 1 |

그리고 계산을 할때, 뒷 수의 부호비트를 보고, 양수면 전가산기로, 음수면 전감산기로 계산합니다.

- 부호비트가 있으면 0이 두개 생깁니다(음의 0, 양의 0) 이걸 처리하는 회로를 따로 만들어야됩니다.

그랬었는데…

# 2의 보수

슈퍼 짱천재 폰 노이만 센세가 1945년에 논문으로 “**2의 보수 음수 표기법”** 이라는걸 생각해냅니다

- 전감산기가 필요없고, 전가산기로 뺄셈을 할 수 있습니다.
- 두개의 0 문제가 없어집니다. 그걸 처리하는 회로도 필요없습니다

![image.png](2%E2%80%99s%20Complement(2%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%A9%E1%84%89%E1%85%AE%E1%84%87%E1%85%A5%E1%86%B8)%201bc80ae0869c8153a420c4e352ddd215/image%201.png)

노이만 센세가 생각해낸 아이디어는 간단한데,


💡

맨 앞에 있는 비트를 나머지 비트 다더한거에서 빼기로 하고 음수랑 양수를 둘 다 표현한다

</aside>

예를 들어,

- 1101 은 101 - 1000 임.
    - 101 - 1000 = 5 - 8 = -3
- 0110 은 0110 - 0000 임.
    - 걍 6

맨 왼쪽 비트는 항상 나머지 비트를 다 합친 것보다 크기 때문에, 부호비트방식과 똑같이, **맨 왼쪽비트가 1 이면 전체 수는 음수입니다.**

# 음수 값의 크기

부호비트표시방식에서는 양수의 부호비트를 1 로 하면, 그 수랑 똑같은 크기의 음수가 되었습니다.

7 앞에 1을 붙이면 -7 이 되는식이죠

근데 2의보수 음수 표현법에서는 음수의 크기가 딱 양수랑 같지 않습니다

2의보수법 표현에서,

어떤 수의 맨 앞 비트에 1을 추가한 수는

```
0011 = 3
1011 = 3-8 = -5
011 - 1000
= 011 - 111 -1
```

3 - 8 = 3 **+** (2 - 10) = 3 + [(**10-8)** - 10]

예를 들어, 1011 와 크기가 같고 부호가 다른 음수는

1011 과 더해서 0000 이 되도록 하는 수입니다

반전된 비트(1의 보수라고 부릅니다. 각 비트를 not 한거임) 에 대해,

원래 숫자와 반전된 숫자(1의 보수)를 더하면 모든 자리가 1인 숫자가 됩니다.(당연하다)

이 “모든 자리가 1인 수”에 “1”을 더하면, N자리 숫자에 대해 N+1 은 1이고 N부터 0까지의 모든 자리는 0 인 (예를 들어, 1111 이면 10000) 숫자가 나옵니다

그러므로, 반전한 수를 더하고 1을 더해서 N+1 짜리 10…00 을 만들고,

맨 왼쪽 비트를 회로로 제거하면 된다.